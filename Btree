
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <inttypes.h>
#include <errno.h>

int proxima_matricula_id = 1;

#define ORDEM 4
typedef enum { SIM = 1, NAO = 0 } Folha;

typedef uint64_t KeyType;
typedef int64_t  OffType;

typedef struct BTreeNode {
    Folha folha;
    int qnt_keys;
    KeyType chaves[ORDEM - 1];
    OffType offsets[ORDEM - 1];
    struct BTreeNode *filhos[ORDEM];
} BTreeNode;

/// ALUNO
typedef struct {
    int matricula;
    char nome[128];
    int active;
} AlunoRec;

/* DISCIPLINAS */
typedef struct {
    char codigo[32];
    char nome[128];
    int active;
} DisciplinaRec;

/* MATRICULA */
typedef struct {
    int id_matricula;
    int matricula_aluno;
    int codigo_disciplina;
    float media_final;
    int active;
} MatriculaRec;

BTreeNode* criar_BTree(Folha folha);
void traverse(BTreeNode *root);
void split_child(BTreeNode *pai, int idx);
void inserirNonFull(BTreeNode *no, KeyType key, OffType offset);
void inserir_idx(BTreeNode **raiz, KeyType key, OffType offset);
OffType buscar_idx(BTreeNode *root, KeyType key); /* retorna offset ou -1 */
void free_tree(BTreeNode *root);
BTreeNode* carregar_arvore(const char *nome_arquivo);

unsigned long hash_str(const char *s);

void carregar_indices();
void rebuild_index_alunos();
void rebuild_index_disciplinas();
void rebuild_index_matriculas();
void lerArqAlunos(FILE* arquivo);
void lerArqDisciplinas(FILE* arquivo);
void lerArqMatriculas(FILE* arquivo);

OffType append_aluno(const AlunoRec *r);
OffType append_disciplina(const DisciplinaRec *r);
OffType append_matricula(const MatriculaRec *r);
int update_matricula_media_by_id(int id, float new_media);
int mark_aluno_inactive_at_offset(OffType off);
int mark_disciplina_inactive_at_offset(OffType off);
int mark_matricula_inactive_at_offset(OffType off);

int criar_aluno(int matricula, const char *nome);
int ler_aluno(int matricula, AlunoRec *out);
int atualizar_aluno(int matricula, const char *novo_nome);
int deletar_aluno(int matricula); 

int criar_disciplina(const char *codigo, const char *nome);
int ler_disciplina(const char *codigo, DisciplinaRec *out);
int atualizar_disciplina(const char *codigo, const char *novo_nome);
int deletar_disciplina(const char *codigo); 

int criar_matricula(int matricula_aluno, const char *codigo, float media_final);
int ler_matricula(int id_matricula, MatriculaRec *out);
int deletar_matricula(int id_matricula);
int atualizar_media_matricula(int id_matricula, float nova_media);

BTreeNode *idx_alunos = NULL;       
BTreeNode *idx_disciplinas = NULL;   
BTreeNode *idx_matriculas = NULL;    

const char *ALUNOS_DAT = "alunos.dat";
const char *DISC_DAT = "disciplinas.dat";
const char *MATR_DAT = "matriculas.dat";

const char *ALUNOS_IDX = "alunos.idx";
const char *DISC_IDX = "disciplinas.idx";
const char *MATR_IDX = "matriculas.idx";

BTreeNode *criar_BTree(Folha folha) {
    BTreeNode *novo = (BTreeNode*)malloc(sizeof(BTreeNode));
    if (!novo) { perror("malloc"); exit(EXIT_FAILURE); }
    novo->folha = folha;
    novo->qnt_keys = 0;
    for (int i = 0; i < ORDEM; ++i) novo->filhos[i] = NULL;
    for (int i = 0; i < ORDEM - 1; ++i) { novo->chaves[i] = 0; novo->offsets[i] = -1; }
    return novo;
}

OffType buscar_idx(BTreeNode *root, KeyType key) {
    if (!root) return -1;
    int i = 0;
    while (i < root->qnt_keys && key > root->chaves[i]) i++;
    if (i < root->qnt_keys && key == root->chaves[i]) return root->offsets[i];
    if (root->folha == SIM) return -1;
    return buscar_idx(root->filhos[i], key);
}

BTreeNode* carregar_arvore(const char *nome_arquivo) {
    FILE *f = fopen(nome_arquivo, "rb");
    if (!f) {
        return NULL;
    }

    BTreeNode *raiz = NULL;
    KeyType key;
    OffType off;

    while (1) {
        size_t r1 = fread(&key, sizeof(KeyType), 1, f);
        size_t r2 = fread(&off, sizeof(OffType), 1, f);

        if (r1 != 1 || r2 != 1)
            break;
        inserir_idx(&raiz, key, off);
    }

    fclose(f);
    return raiz;
}

void split_child(BTreeNode *pai, int idx) {
    BTreeNode *filho = pai->filhos[idx];
    if (!filho) return;
    int max_keys = ORDEM - 1;
    int mid = max_keys / 2; 
    BTreeNode *novo = criar_BTree(filho->folha);

    int rightCount = filho->qnt_keys - mid - 1;
    for (int j = 0; j < rightCount; ++j) {
        novo->chaves[j] = filho->chaves[mid + 1 + j];
        novo->offsets[j] = filho->offsets[mid + 1 + j];
    }
    if (filho->folha == NAO) {
        for (int j = 0; j <= rightCount; ++j) {
            novo->filhos[j] = filho->filhos[mid + 1 + j];
            filho->filhos[mid + 1 + j] = NULL;
        }
    }
    novo->qnt_keys = rightCount;
    filho->qnt_keys = mid;

    for (int j = pai->qnt_keys; j >= idx + 1; --j) {
        pai->filhos[j + 1] = pai->filhos[j];
    }
    pai->filhos[idx + 1] = novo;

    for (int j = pai->qnt_keys - 1; j >= idx; --j) {
        pai->chaves[j + 1] = pai->chaves[j];
        pai->offsets[j + 1] = pai->offsets[j];
    }
    pai->chaves[idx] = filho->chaves[mid];
    pai->offsets[idx] = filho->offsets[mid];
    pai->qnt_keys += 1;
}

void inserirNonFull(BTreeNode *no, KeyType key, OffType offset) {
    int i = no->qnt_keys - 1;
    if (no->folha == SIM) {
        while (i >= 0 && no->chaves[i] > key) {
            no->chaves[i + 1] = no->chaves[i];
            no->offsets[i + 1] = no->offsets[i];
            i--;
        }
        if (i >= 0 && no->chaves[i] == key) { 
            no->offsets[i] = offset;
            return;
        }
        no->chaves[i + 1] = key;
        no->offsets[i + 1] = offset;
        no->qnt_keys += 1;
    } else {
        while (i >= 0 && no->chaves[i] > key) i--;
        i++;
        if (!no->filhos[i]) no->filhos[i] = criar_BTree(SIM);
        if (no->filhos[i]->qnt_keys == ORDEM - 1) {
            split_child(no, i);
            if (no->chaves[i] == key) { no->offsets[i] = offset; return; }
            if (no->chaves[i] < key) i++;
        }
        inserirNonFull(no->filhos[i], key, offset);
    }
}

void inserir_idx(BTreeNode **raiz, KeyType key, OffType offset) {
    if (!*raiz) {
        *raiz = criar_BTree(SIM);
        (*raiz)->chaves[0] = key;
        (*raiz)->offsets[0] = offset;
        (*raiz)->qnt_keys = 1;
        return;
    }
    if (buscar_idx(*raiz, key) != -1) {
        BTreeNode *cur = *raiz;
        while (1) {
            int i = 0;
            while (i < cur->qnt_keys && key > cur->chaves[i]) i++;
            if (i < cur->qnt_keys && key == cur->chaves[i]) {
                cur->offsets[i] = offset; return;
            }
            if (cur->folha == SIM) break;
            cur = cur->filhos[i];
        }
    }
    BTreeNode *r = *raiz;
    if (r->qnt_keys == ORDEM - 1) {
        BTreeNode *s = criar_BTree(NAO);
        s->filhos[0] = r;
        split_child(s, 0);
        int i = 0;
        if (s->chaves[0] < key) i = 1;
        inserirNonFull(s->filhos[i], key, offset);
        *raiz = s;
    } else {
        inserirNonFull(r, key, offset);
    }
}

void traverse(BTreeNode *root) {
    if (!root) return;
    int i;
    for (i = 0; i < root->qnt_keys; ++i) {
        traverse(root->filhos[i]);
        printf("%" PRIu64 "->%lld ", root->chaves[i], (long long)root->offsets[i]);
    }
    traverse(root->filhos[i]);
}

void free_tree(BTreeNode *root) {
    if (!root) return;
    for (int i = 0; i <= root->qnt_keys; ++i) free_tree(root->filhos[i]);
    free(root);
}


unsigned long hash_str(const char *s){
    unsigned long valor = 0;
    int i = 0;
    int d = 2;
    while(s[i] != '\0'){
        valor += (unsigned char)s[i] * (unsigned long)d;
        i++; d++;
    }
    return valor;
}


void carregar_indices() {
    printf("Carregando indices do disco");

    idx_alunos      = carregar_arvore(ALUNOS_IDX);
    idx_disciplinas = carregar_arvore(DISC_IDX);
    idx_matriculas  = carregar_arvore(MATR_IDX);


    FILE* fmat = fopen(MATR_DAT, "rb");
    if (!fmat) {
        proxima_matricula_id = 1;
        return;
    }

    MatriculaRec reg;
    int maior_id = 0;
    while (fread(&reg, sizeof(MatriculaRec), 1, fmat) == 1) {
        if (reg.id_matricula > maior_id) {
            maior_id = reg.id_matricula;
        }
    }
    fclose(fmat);
    proxima_matricula_id = maior_id + 1;
    
}

void rebuild_index_alunos() {
    FILE *f = fopen(ALUNOS_DAT, "rb");
    if (!f) return;
    FILE *fi = fopen(ALUNOS_IDX, "wb");
    if (!fi) { fclose(f); return; }
    free_tree(idx_alunos); idx_alunos = NULL;
    AlunoRec r;
    while (fread(&r, sizeof(AlunoRec), 1, f) == 1) {
        if (r.active) {
            long off = (long)(ftell(f) - (long)sizeof(AlunoRec));
            KeyType key = (KeyType)r.matricula;
            OffType offt = (OffType)off;
            fwrite(&key, sizeof(KeyType), 1, fi);
            fwrite(&offt, sizeof(OffType), 1, fi);
            inserir_idx(&idx_alunos, key, offt);
        }
    }
    fclose(f); fclose(fi);
}

void rebuild_index_disciplinas() {
    FILE *f = fopen(DISC_DAT, "rb");
    if (!f) return;
    FILE *fi = fopen(DISC_IDX, "wb");
    if (!fi) { fclose(f); return; }
    free_tree(idx_disciplinas); idx_disciplinas = NULL;
    DisciplinaRec r;
    while (fread(&r, sizeof(DisciplinaRec), 1, f) == 1) {
        if (r.active) {
            long off = (long)(ftell(f) - (long)sizeof(DisciplinaRec));
            KeyType key = (KeyType)hash_str(r.codigo);
            OffType offt = (OffType)off;
            fwrite(&key, sizeof(KeyType), 1, fi);
            fwrite(&offt, sizeof(OffType), 1, fi);
            inserir_idx(&idx_disciplinas, key, offt);
        }
    }
    fclose(f); fclose(fi);
}

void rebuild_index_matriculas() {
    
    FILE *f = fopen(MATR_DAT, "rb");
    if (!f) return;

    FILE *fi = fopen(MATR_IDX, "wb");
    if (!fi) { fclose(f); return; }

    free_tree(idx_matriculas); 
    idx_matriculas = NULL;

    MatriculaRec r;
    while (fread(&r, sizeof(MatriculaRec), 1, f) == 1) {
        if (r.active) {
            
            long off = (long)(ftell(f) - (long)sizeof(MatriculaRec));
            
            KeyType key = (KeyType)r.id_matricula;
            OffType offt = (OffType)off;

            
            fwrite(&key, sizeof(KeyType), 1, fi);
            fwrite(&offt, sizeof(OffType), 1, fi);

            
            inserir_idx(&idx_matriculas, key, offt);
        }
    }

    fclose(f);
    fclose(fi);
}

OffType append_aluno(const AlunoRec *r) {
    FILE *f = fopen(ALUNOS_DAT, "ab");
    if (!f) return -1;
    long off = ftell(f);
    fwrite(r, sizeof(AlunoRec), 1, f);
    fclose(f);
    return (OffType)off;
}

OffType append_disciplina(const DisciplinaRec *r) {
    FILE *f = fopen(DISC_DAT, "ab");
    if (!f) return -1;
    long off = ftell(f);
    fwrite(r, sizeof(DisciplinaRec), 1, f);
    fclose(f);
    return (OffType)off;
}

OffType append_matricula(const MatriculaRec *r) {
    FILE *f = fopen(MATR_DAT, "ab");
    if (!f) return -1;

    fseek(f, 0, SEEK_END);
    OffType off = ftell(f);

    fwrite(r, sizeof(MatriculaRec), 1, f);
    fclose(f);

    return off;
}

int mark_aluno_inactive_at_offset(OffType off) {
    FILE *f = fopen(ALUNOS_DAT, "r+b");
    if (!f) return 0;
    if (fseek(f, (long)off, SEEK_SET) != 0) { fclose(f); return 0; }
    AlunoRec r;
    if (fread(&r, sizeof(AlunoRec), 1, f) != 1) { fclose(f); return 0; }
    r.active = 0;
    if (fseek(f, (long)off, SEEK_SET) != 0) { fclose(f); return 0; }
    fwrite(&r, sizeof(AlunoRec), 1, f);
    fclose(f);
    return 1;
}

int mark_disciplina_inactive_at_offset(OffType off) {
    FILE *f = fopen(DISC_DAT, "r+b");
    if (!f) return 0;
    if (fseek(f, (long)off, SEEK_SET) != 0) { fclose(f); return 0; }
    DisciplinaRec r;
    if (fread(&r, sizeof(DisciplinaRec), 1, f) != 1) { fclose(f); return 0; }
    r.active = 0;
    if (fseek(f, (long)off, SEEK_SET) != 0) { fclose(f); return 0; }
    fwrite(&r, sizeof(DisciplinaRec), 1, f);
    fclose(f);
    return 1;
}

int mark_matricula_inactive_at_offset(OffType off) {
    FILE *f = fopen(MATR_DAT, "r+b");
    if (!f) return 0;
    if (fseek(f, (long)off, SEEK_SET) != 0) { fclose(f); return 0; }
    MatriculaRec r;
    if (fread(&r, sizeof(MatriculaRec), 1, f) != 1) { fclose(f); return 0; }
    r.active = 0;
    if (fseek(f, (long)off, SEEK_SET) != 0) { fclose(f); return 0; }
    fwrite(&r, sizeof(MatriculaRec), 1, f);
    fclose(f);
    return 1;
}

int update_matricula_media_by_id(int id, float new_media) {
    OffType off = buscar_idx(idx_matriculas, (KeyType)id);
    if (off < 0) return 0;
    FILE *f = fopen(MATR_DAT, "r+b");
    if (!f) return 0;
    if (fseek(f, (long)off, SEEK_SET) != 0) { fclose(f); return 0; }
    MatriculaRec r;
    if (fread(&r, sizeof(MatriculaRec), 1, f) != 1) { fclose(f); return 0; }
    if (!r.active) { fclose(f); return 0; }
    r.media_final = new_media;
    if (fseek(f, (long)off, SEEK_SET) != 0) { fclose(f); return 0; }
    fwrite(&r, sizeof(MatriculaRec), 1, f);
    fclose(f);
    return 1;
}

/////////////////////////////////////////////
/////--------*ALUNOS*--------------/////////
//////////////////////////////////////////

void listar_disciplinas_do_aluno(int matricula) {
    
    AlunoRec a;
    if (!ler_aluno(matricula, &a)) {
        printf("Aluno %d nao encontrado.\n", matricula);
        return;
    }
    printf("-----------------------------------------------------\n");
    printf(" Boletim do Aluno: %s (Matr: %d)\n", a.nome, a.matricula);
    printf("-----------------------------------------------------\n");

    FILE *f = fopen(MATR_DAT, "rb"); 
    if (!f) {
        printf("Nenhuma matricula registrada no sistema.\n");
        return;
    }

    MatriculaRec m;
    int encontrou = 0;

    while (fread(&m, sizeof(MatriculaRec), 1, f) == 1) {
        if (m.active && m.matricula_aluno == matricula) {
            
            char nome_disc[128] = "Disciplina Desconhecida";
            char cod_disc[32]   = "---";

            OffType off_disc = buscar_idx(idx_disciplinas, (KeyType)m.codigo_disciplina);
            
            if (off_disc >= 0) {
                FILE *fd = fopen(DISC_DAT, "rb");
                if (fd) {
                    DisciplinaRec d;
                    fseek(fd, (long)off_disc, SEEK_SET);
                    if (fread(&d, sizeof(DisciplinaRec), 1, fd) == 1) {
                        strncpy(nome_disc, d.nome, sizeof(nome_disc));
                        strncpy(cod_disc, d.codigo, sizeof(cod_disc));
                    }
                    fclose(fd);
                }
            }

            printf("  [%s] %-20s | Media: %.2f\n", cod_disc, nome_disc, m.media_final);
            encontrou = 1;
        }
    }
    
    if (!encontrou) printf("  (Este aluno nao possui matriculas ativas)\n");
    
    fclose(f);
    printf("-----------------------------------------------------\n");
}

int criar_aluno(int matricula, const char *nome) {
    if (buscar_idx(idx_alunos, (KeyType)matricula) != -1)
        return 0;

    AlunoRec r;
    r.matricula = matricula;
    r.active = 1;
    memset(r.nome, 0, sizeof(r.nome));
    if (nome) {
        strncpy(r.nome, nome, sizeof(r.nome) - 1);
        r.nome[sizeof(r.nome) - 1] = '\0';
    }

    OffType off = append_aluno(&r);
    if (off < 0) {
        fprintf(stderr, "Erro: falha ao gravar alunos.dat: %s\n", strerror(errno));
        return 0;
    }

    FILE *fi = fopen(ALUNOS_IDX, "ab");
    if (fi) {
        KeyType k = (KeyType)matricula;
        OffType o = off;
        fwrite(&k, sizeof(KeyType), 1, fi);
        fwrite(&o, sizeof(OffType), 1, fi);
        fclose(fi);
    } 

    inserir_idx(&idx_alunos, (KeyType)matricula, off);

    return 1;
}


int ler_aluno(int matricula, AlunoRec *out) {
    OffType off = buscar_idx(idx_alunos, (KeyType)matricula);
    if (off < 0) return 0;
    FILE *f = fopen(ALUNOS_DAT, "rb");
    if (!f) return 0;
    if (fseek(f, (long)off, SEEK_SET) != 0) { fclose(f); return 0; }
    if (fread(out, sizeof(AlunoRec), 1, f) != 1) { fclose(f); return 0; }
    fclose(f);
    if (!out->active) return 0;
    return 1;
}

int atualizar_aluno(int matricula, const char *novo_nome) {
    OffType off = buscar_idx(idx_alunos, (KeyType)matricula);
    if (off < 0) return 0;
    FILE *f = fopen(ALUNOS_DAT, "r+b");
    if (!f) return 0;
    if (fseek(f, (long)off, SEEK_SET) != 0) { fclose(f); return 0; }
    AlunoRec r;
    if (fread(&r, sizeof(AlunoRec), 1, f) != 1) { fclose(f); return 0; }
    if (!r.active) { fclose(f); return 0; }
    strncpy(r.nome, novo_nome, sizeof(r.nome)-1); r.nome[sizeof(r.nome)-1] = '\0';
    if (fseek(f, (long)off, SEEK_SET) != 0) { fclose(f); return 0; }
    fwrite(&r, sizeof(AlunoRec), 1, f);
    fclose(f);
    return 1;
}

int deletar_aluno(int matricula) {
    OffType off = buscar_idx(idx_alunos, (KeyType)matricula);
    if (off < 0) return 0;

    if (!mark_aluno_inactive_at_offset(off)) return 0;

    FILE *f = fopen(MATR_DAT, "r+b"); 
    if (f) {
        MatriculaRec r;
        long pos;
        while (fread(&r, sizeof(MatriculaRec), 1, f) == 1) {
            pos = ftell(f) - (long)sizeof(MatriculaRec);

            if (r.active && r.matricula_aluno == matricula) {
                r.active = 0;
                
                if (fseek(f, pos, SEEK_SET) == 0) {
                    fwrite(&r, sizeof(MatriculaRec), 1, f);
                    
                    fseek(f, 0, SEEK_CUR); 
                }
            }
        }
        fclose(f);
    }

    rebuild_index_alunos();
    rebuild_index_matriculas();
    
    return 1;
}

//////////////////////////////////////////////////////

/////////////////////////////////////////////
/////--------*DISCIPLINAS*--------------/////////
//////////////////////////////////////////

void listar_alunos_da_disciplina(const char *codigo_disciplina) {
    DisciplinaRec d;
    if (!ler_disciplina(codigo_disciplina, &d)) {
        printf("Disciplina '%s' nao encontrada no indice.\n", codigo_disciplina);
        return;
    }
    printf("---Disciplina: %s (%s) ---\n", d.nome, d.codigo);

    int hash_alvo = (int)hash_str(codigo_disciplina);
    
    FILE *f = fopen(MATR_DAT, "rb"); 
    if (!f) {
        printf("Arquivo de matriculas (%s) nao encontrado.\n", MATR_DAT);
        return;
    }

    MatriculaRec m;
    int total = 0;
    int registros_lidos = 0;

    while (fread(&m, sizeof(MatriculaRec), 1, f) == 1) {
        registros_lidos++;

        if (m.active && m.codigo_disciplina == hash_alvo) {
            
            AlunoRec aluno;
            if (ler_aluno(m.matricula_aluno, &aluno)) {
                 printf("  -> Matricula: %d | Nome: %s | Media: %.2f\n", 
                        aluno.matricula, aluno.nome, m.media_final);
            } else {
                 printf("  -> Matricula: %d (Nome indisponivel no cadastro)\n", m.matricula_aluno);
            }
            total++;
        }
    }
    
    if (total == 0) {
        printf("  (Nenhum aluno matriculado nesta disciplina)\n");
        printf("   Foram lidos %d registros no arquivo de matriculas]\n", registros_lidos);
    } else {
        printf("Total de alunos: %d\n", total);
    }
    
    fclose(f);
}

int criar_disciplina(const char *codigo, const char *nome) {
    uint64_t h = hash_str(codigo);
    OffType existente = buscar_idx(idx_disciplinas, (KeyType)h);
    if (existente != -1) {
        if (existente >= 0) {
            FILE *f = fopen(DISC_DAT, "rb");
            if (f) {
                if (fseek(f, (long)existente, SEEK_SET) == 0) {
                    DisciplinaRec r;
                    if (fread(&r, sizeof(DisciplinaRec), 1, f) == 1) {
                        if (r.active && strcmp(r.codigo, codigo) == 0) { fclose(f); return 0; }
                    }
                }
                fclose(f);
            }
        }
    }
    DisciplinaRec r; r.active = 1;
    strncpy(r.codigo, codigo, sizeof(r.codigo)-1); r.codigo[sizeof(r.codigo)-1] = '\0';
    strncpy(r.nome, nome, sizeof(r.nome)-1); r.nome[sizeof(r.nome)-1] = '\0';
    OffType off = append_disciplina(&r);
    if (off < 0) return 0;
    FILE *fi = fopen(DISC_IDX, "ab");
    if (fi) { KeyType k = (KeyType)h; OffType o = off; fwrite(&k, sizeof(KeyType), 1, fi); fwrite(&o, sizeof(OffType), 1, fi); fclose(fi); }
    inserir_idx(&idx_disciplinas, (KeyType)h, off);
    return 1;
}

int ler_disciplina(const char *codigo, DisciplinaRec *out) {
    uint64_t h = hash_str(codigo);
    OffType off = buscar_idx(idx_disciplinas, (KeyType)h);
    if (off < 0) return 0;
    FILE *f = fopen(DISC_DAT, "rb");
    if (!f) return 0;
    if (fseek(f, (long)off, SEEK_SET) != 0) { fclose(f); return 0; }
    if (fread(out, sizeof(DisciplinaRec), 1, f) != 1) { fclose(f); return 0; }
    fclose(f);
    if (!out->active) return 0;
    /* checar string (colisão possível) */
    if (strcmp(out->codigo, codigo) != 0) return 0;
    return 1;
}

int atualizar_disciplina(const char *codigo, const char *novo_nome) {
    uint64_t h = hash_str(codigo);
    OffType off = buscar_idx(idx_disciplinas, (KeyType)h);
    if (off < 0) return 0;
    FILE *f = fopen(DISC_DAT, "r+b");
    if (!f) return 0;
    if (fseek(f, (long)off, SEEK_SET) != 0) { fclose(f); return 0; }
    DisciplinaRec r;
    if (fread(&r, sizeof(DisciplinaRec), 1, f) != 1) { fclose(f); return 0; }
    if (!r.active || strcmp(r.codigo, codigo) != 0) { fclose(f); return 0; }
    strncpy(r.nome, novo_nome, sizeof(r.nome)-1); r.nome[sizeof(r.nome)-1] = '\0';
    if (fseek(f, (long)off, SEEK_SET) != 0) { fclose(f); return 0; }
    fwrite(&r, sizeof(DisciplinaRec), 1, f);
    fclose(f);
    return 1;
}

int deletar_disciplina(const char *codigo) {
    uint64_t h = hash_str(codigo);
    OffType off = buscar_idx(idx_disciplinas, (KeyType)h);
    if (off < 0) return 0;

    if (!mark_disciplina_inactive_at_offset(off)) return 0;

    FILE *f = fopen("matriculas.dat", "r+b"); 
    if (f) {
        MatriculaRec r;
        long pos;
        
        while (fread(&r, sizeof(MatriculaRec), 1, f) == 1) {
            
            pos = ftell(f) - (long)sizeof(MatriculaRec);

            if (r.active && r.codigo_disciplina == (int)h) {
                r.active = 0;

                if (fseek(f, pos, SEEK_SET) == 0) {
                   
                    fwrite(&r, sizeof(MatriculaRec), 1, f);

                    fseek(f, 0, SEEK_CUR); 
                }
            }
        }
        fclose(f);
    }

    rebuild_index_disciplinas();
    rebuild_index_matriculas();
    
    return 1;
}
/////////////////////////////////////////////
/////--------*MATRICULAS*--------------/////////
//////////////////////////////////////////

int existe_matricula(int mat_aluno, const char *cod_disciplina) {
    unsigned long hash_disc = hash_str(cod_disciplina);
    
    FILE *f = fopen(MATR_DAT, "rb"); 
    if (!f) return 0; 

    MatriculaRec r;
    int existe = 0;
    
    while (fread(&r, sizeof(MatriculaRec), 1, f) == 1) {
        if (r.active && r.matricula_aluno == mat_aluno && r.codigo_disciplina == (int)hash_disc) {
            existe = 1;
            break;
        }
    }
    fclose(f);
    return existe;
}

void lerArqMatriculas(FILE* arquivo) {
    if (!arquivo) return;

    char linha[512];
    int count = 0;
    int duplicadas = 0;

    long pos_inicial = ftell(arquivo);
    if (fgets(linha, sizeof(linha), arquivo) != NULL) {
        if (linha[0] >= '0' && linha[0] <= '9') {
            fseek(arquivo, pos_inicial, SEEK_SET);
        }
    }

    while (fgets(linha, sizeof(linha), arquivo) != NULL) {
        char *token;
        int matricula_aluno = 0;
        char cod_disciplina[64] = {0};
        float media = -1.0f;

        linha[strcspn(linha, "\n")] = 0;

        // 1. ID
        token = strtok(linha, ",");
        if (!token) continue;

        token = strtok(NULL, ",");
        if (!token) continue;
        matricula_aluno = atoi(token);

        token = strtok(NULL, ",");
        if (!token) continue;
        strncpy(cod_disciplina, token, sizeof(cod_disciplina)-1);

        // 4. Ano 
        strtok(NULL, ",");
        // 5. Semestre 
        strtok(NULL, ",");

        token = strtok(NULL, ",");
        if (token && strlen(token) > 0) {
            media = (float)atof(token);
        }

        if (existe_matricula(matricula_aluno, cod_disciplina)) {
            duplicadas++;
            continue; 
        }

        if (criar_matricula(matricula_aluno, cod_disciplina, media)) {
            count++;
        }
    }
}

int criar_matricula(int matricula_aluno, const char *cod_disciplina, float media_final)
{
    if (buscar_idx(idx_alunos, (KeyType)matricula_aluno) == -1) return 0;

    unsigned long cod_hash = hash_str(cod_disciplina);
    if (buscar_idx(idx_disciplinas, (KeyType)cod_hash) == -1) return 0;

    int id_matricula = proxima_matricula_id++; 

    MatriculaRec r;
    r.id_matricula = id_matricula;
    r.matricula_aluno = matricula_aluno;
    r.codigo_disciplina = (int)cod_hash;
    r.media_final = media_final;
    r.active = 1;

    OffType off = append_matricula(&r);
    if (off < 0) return 0;

    FILE *fi = fopen(MATR_IDX, "ab"); 
    if (fi) {
        KeyType k = (KeyType)id_matricula;
        fwrite(&k, sizeof(KeyType), 1, fi);
        fwrite(&off, sizeof(OffType), 1, fi);
        fclose(fi);
    } else {
        printf("Erro: Nao foi possivel gravar\n");
    }

    inserir_idx(&idx_matriculas, (KeyType)id_matricula, off);

    return 1;
}
int ler_matricula(int id_matricula, MatriculaRec *out) {
    OffType off = buscar_idx(idx_matriculas, (KeyType)id_matricula);
    if (off < 0) return 0;
    FILE *f = fopen(MATR_DAT, "rb");
    if (!f) return 0;
    if (fseek(f, (long)off, SEEK_SET) != 0) { fclose(f); return 0; }
    if (fread(out, sizeof(MatriculaRec), 1, f) != 1) { fclose(f); return 0; }
    fclose(f);
    if (!out->active) return 0;
    return 1;
}

int deletar_matricula(int id_matricula) {
    OffType off = buscar_idx(idx_matriculas, (KeyType)id_matricula);
    if (off < 0) return 0;
    if (!mark_matricula_inactive_at_offset(off)) return 0;
    rebuild_index_matriculas();
    return 1;
}

int atualizar_media_matricula(int id_matricula, float nova_media) {
    return update_matricula_media_by_id(id_matricula, nova_media);
}

void menu() {

    int opc = 0;

    while (1) {
        printf("\n--- Menu ---\n");
        printf("1) Criar Aluno\n2) Ler Aluno\n3) Atualizar Aluno\n4) Deletar Aluno\n");
        printf("5) Criar Disciplina\n6) Ler Disciplina\n7) Atualizar Disciplina\n8) Deletar Disciplina\n");
        printf("0) Sair\n> ");

        if (scanf("%d", &opc) != 1) {
            while (getchar() != '\n');
            continue;
        }

        if (opc == 0)
            break;

        if (opc == 1) {
            int m;
            char nome[128];

            printf("Matricula (int): ");
            scanf("%d", &m);
            getchar();

            printf("Nome: ");
            fgets(nome, sizeof(nome), stdin);
            nome[strcspn(nome, "\n")] = '\0';

            if (criar_aluno(m, nome))
                printf("Aluno criado.\n");
            else
                printf("Falha: aluno já existe.\n");

        } else if (opc == 2) {
            int m;
            AlunoRec a;

            printf("Matricula: ");
            scanf("%d", &m);

            if (ler_aluno(m, &a))
                listar_disciplinas_do_aluno(m);
            else
                printf("Aluno não encontrado.\n");

        } else if (opc == 3) {
            int m;
            printf("Digite a Matricula do Aluno: ");
            scanf("%d", &m);

            listar_disciplinas_do_aluno(m); 

            char cod_digitado[32];
            printf("\nDigite o CODIGO da disciplina para alterar: ");
            scanf("%31s", cod_digitado);
            
            float nova_media;
            printf("Digite a nova media final: ");
            scanf("%f", &nova_media);
            
            int id_encontrado = -1;
            int hash_buscado = (int)hash_str(cod_digitado); 

            FILE *f = fopen(MATR_DAT, "rb"); 
            if (f) {
                MatriculaRec temp;
                while (fread(&temp, sizeof(MatriculaRec), 1, f) == 1) {
                    if (temp.active && 
                        temp.matricula_aluno == m && 
                        temp.codigo_disciplina == hash_buscado) {
                        
                        id_encontrado = temp.id_matricula;
                        break; 
                    }
                }
                fclose(f);
            }

            if (id_encontrado != -1) {
                if (atualizar_media_matricula(id_encontrado, nova_media)) {
                    printf(">> Sucesso: Nota da disciplina '%s' atualizada para %.2f.\n", cod_digitado, nova_media);
                } else {
                    printf(">> Erro ao gravar atualização.\n");
                }
            } 
            else return;
        } else if (opc == 4) {
            int m;

            printf("Matricula: ");
            scanf("%d", &m);

            if (deletar_aluno(m))
                printf("Aluno deletado.\n");
            else
                printf("Falha.\n");

        } else if (opc == 5) {
            char cod[32], nome[128];

            printf("Codigo: ");
            scanf("%31s", cod);
            getchar();

            printf("Nome disciplina: ");
            fgets(nome, sizeof(nome), stdin);
            nome[strcspn(nome, "\n")] = '\0';

            if (criar_disciplina(cod, nome))
                printf("Disciplina criada.\n");
            else
                printf("Falha: ja existe.\n");

        } else if (opc == 6) {
            char cod[32];
            DisciplinaRec d;

            printf("Codigo: ");
            scanf("%31s", cod);

            if (ler_disciplina(cod, &d)){
                listar_alunos_da_disciplina(cod);}
            else{
                printf("Disciplina não encontrada.\n");}

        } else if (opc == 7) {
            char cod[32], nome[128];

            printf("Codigo: ");
            scanf("%31s", cod);
            getchar();

            printf("Novo nome: ");
            fgets(nome, sizeof(nome), stdin);
            nome[strcspn(nome, "\n")] = '\0';

            if (atualizar_disciplina(cod, nome))
                printf("Atualizada.\n");
            else
                printf("Falha.\n");

        } else if (opc == 8) {
            char cod[32];

            printf("Codigo: ");
            scanf("%31s", cod);

            if (deletar_disciplina(cod))
                printf("Disciplina deletada.\n");
            else
                printf("Falha.\n");

        } 
        else {
            printf("Opcao invalida.\n");
        }
    }
}


void lerArqAlunos(FILE* arquivo){
    if (!arquivo) return;

    char linha[512];

    while (fgets(linha, sizeof(linha), arquivo) != NULL) {

        int matricula = 0;
        char nome[128] = {0};

        char *token = strtok(linha, ",\n");
        if (!token) continue;
        matricula = atoi(token);

        token = strtok(NULL, ",\n");
        if (!token) continue;
        strncpy(nome, token, sizeof(nome)-1);

        criar_aluno(matricula, nome);
    }
}

void lerArqDisciplinas(FILE* arquivo){
    if (!arquivo) return;
    char linha[512];
    while (fgets(linha, sizeof(linha), arquivo) != NULL){
        char cod[32] = {0};
        char nome[128] = {0};
        char *token;
        token = strtok(linha,",\n");
        if (token != NULL){
            strncpy(cod, token, sizeof(cod)-1);
        }
        token = strtok(NULL, ",\n");
        if (token != NULL) {
            strncpy(nome, token, sizeof(nome)-1);
        }
        if (!criar_disciplina(cod,nome)) {
            
        }
    }
}

int main(void) {
carregar_indices();
    
    if (idx_alunos == NULL) {
        printf("Primeira execucao detectada. Importando CSVs...\n");

        FILE* alunos = fopen("alunos.csv","r");
        if (alunos) { lerArqAlunos(alunos); fclose(alunos); }

        FILE* cadeiras = fopen("disciplinas.csv","r");
        if (cadeiras) { lerArqDisciplinas(cadeiras); fclose(cadeiras); }

        FILE* matriculas = fopen("matricula_aluno.csv","r");
        if (matriculas) { lerArqMatriculas(matriculas); fclose(matriculas); }
        
        rebuild_index_alunos();
        rebuild_index_disciplinas();
        rebuild_index_matriculas();
    } 
    menu();
    
    free_tree(idx_alunos);
    free_tree(idx_disciplinas);
    free_tree(idx_matriculas);

    return 0;
}
